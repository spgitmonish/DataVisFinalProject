<!--
1. Use Avg Debt for changing the color
2. Use Per Debt to change the size of the circle which points to the capital
3. That way one can display two things at once
-->
<!DOCTYPE html>
<html>
    <meta charset = "utf-8">
    <style>
        .legend {
            font-size: 12px;
        }
        rect {
            stroke-width: 2;
        }

        h2 {
          text-align: center;
          color: black;
        }

        .state rect {
            fill: #dedede;
        }

        .state text {
            font: 12px sans-serif;
            text-anchor: middle;
        }

        .symbol {
            fill: steelblue;
            fill-opacity: .3;
            stroke: #fff;
        }
    </style>
<head>
    <!-- Add D3 and TopoJSON libraries. -->
    <script id="grid" type="text/plain">
                                  ME
                   WI          VT NH
    WA ID MT ND MN IL MI    NY MA
    OR NV WY SD IA IN OH PA NJ CT RI
    CA UT CO NE MO KY WV VA MD DE
       AZ NM KS AR TN NC SC
             OK LA MS AL GA
    AK HI    TX             FL
    </script>
    <script src = "http://d3js.org/d3.v3.min.js" > </script>
    <script src = "http://d3js.org/topojson.v1.min.js"> </script>

    <!-- Add D3 Scripting here. -->
    <script type="text/javascript">
        function draw(error, us_states) {
            if (error) {
                return console.error(error);
            } else {
                console.log(us_states);
            }

            d3.select("body")
              .append("h2")
              .text("Year ");

            // Define width and height for SVG canvas.
            var width = 1300;
            var height = 1300;

            var states = [];

            d3.select("#grid").text().split("\n").forEach(function(line, i) {
                var re = /\w+/g, m;
                while (m = re.exec(line)) states.push({
                    name: m[0],
                    x: m.index / 3,
                    y: i
                });
            });

            // Append SVG canvas to the DOM.
            var svg = d3.select("body")
                .append("svg")
                .attr("width", width)
                .attr("height", height)
                .append('g')
                .attr('class', 'map');

            // Define the variable states.
            // Assign the "states" variable to the GeoJSON feature collection("geometric collection") for the specified topology object.
            // While TopoJSON data is stored more efficiently, we need to convert back to GeoJSON for display purposes.
            // The function "topojson.feature" is used to return the GeoJSON Feature or FeatureCollection for the specified object in the given topology.
            var statesOne = topojson.feature(us_states, us_states.objects.states);
            var statesTwo = statesOne;

            var usStates = [
                { name: 'ALABAMA', abbreviation: 'AL'},
                { name: 'ALASKA', abbreviation: 'AK'},
                { name: 'ARIZONA', abbreviation: 'AZ'},
                { name: 'ARKANSAS', abbreviation: 'AR'},
                { name: 'CALIFORNIA', abbreviation: 'CA'},
                { name: 'COLORADO', abbreviation: 'CO'},
                { name: 'CONNECTICUT', abbreviation: 'CT'},
                { name: 'DELAWARE', abbreviation: 'DE'},
                { name: 'DISTRICT OF COLUMBIA', abbreviation: 'DC'},
                { name: 'FLORIDA', abbreviation: 'FL'},
                { name: 'GEORGIA', abbreviation: 'GA'},
                { name: 'HAWAII', abbreviation: 'HI'},
                { name: 'IDAHO', abbreviation: 'ID'},
                { name: 'ILLINOIS', abbreviation: 'IL'},
                { name: 'INDIANA', abbreviation: 'IN'},
                { name: 'IOWA', abbreviation: 'IA'},
                { name: 'KANSAS', abbreviation: 'KS'},
                { name: 'KENTUCKY', abbreviation: 'KY'},
                { name: 'LOUISIANA', abbreviation: 'LA'},
                { name: 'MAINE', abbreviation: 'ME'},
                { name: 'MARYLAND', abbreviation: 'MD'},
                { name: 'MASSACHUSETTS', abbreviation: 'MA'},
                { name: 'MICHIGAN', abbreviation: 'MI'},
                { name: 'MINNESOTA', abbreviation: 'MN'},
                { name: 'MISSISSIPPI', abbreviation: 'MS'},
                { name: 'MISSOURI', abbreviation: 'MO'},
                { name: 'MONTANA', abbreviation: 'MT'},
                { name: 'NEBRASKA', abbreviation: 'NE'},
                { name: 'NEVADA', abbreviation: 'NV'},
                { name: 'NEW HAMPSHIRE', abbreviation: 'NH'},
                { name: 'NEW JERSEY', abbreviation: 'NJ'},
                { name: 'NEW MEXICO', abbreviation: 'NM'},
                { name: 'NEW YORK', abbreviation: 'NY'},
                { name: 'NORTH CAROLINA', abbreviation: 'NC'},
                { name: 'NORTH DAKOTA', abbreviation: 'ND'},
                { name: 'OHIO', abbreviation: 'OH'},
                { name: 'OKLAHOMA', abbreviation: 'OK'},
                { name: 'OREGON', abbreviation: 'OR'},
                { name: 'PENNSYLVANIA', abbreviation: 'PA'},
                { name: 'RHODE ISLAND', abbreviation: 'RI'},
                { name: 'SOUTH CAROLINA', abbreviation: 'SC'},
                { name: 'SOUTH DAKOTA', abbreviation: 'SD'},
                { name: 'TENNESSEE', abbreviation: 'TN'},
                { name: 'TEXAS', abbreviation: 'TX'},
                { name: 'UTAH', abbreviation: 'UT'},
                { name: 'VERMONT', abbreviation: 'VT'},
                { name: 'VIRGINIA', abbreviation: 'VA'},
                { name: 'WASHINGTON', abbreviation: 'WA'},
                { name: 'WEST VIRGINIA', abbreviation: 'WV'},
                { name: 'WISCONSIN', abbreviation: 'WI'},
                { name: 'WYOMING', abbreviation: 'WY' }
            ];

            // "states" is an object which has a "type"(FeatureCollection) and a "features" array which is a collection of objects one for each
            // US State, this includes Washington DC
            console.log(statesOne);

            // Create a projection suited to fit the US (pre-defined in the library).
            // A projection simply describes how you want to view your specified area of the globe.
            // Spherical coordinates are projected onto the Cartesian plane (our canvas).
            // Projections can be rotated, scaled, transformed, translated etc.
            var projectionOne = d3.geo.albersUsa()
                .translate([(width + 100) / 2, height * 0.25])
                .scale(1400);

            var projectionTwo = d3.geo.albersUsa()
                .translate([(width + 150) / 2, height * 0.5])
                .scale(700);

            // Create a path generator to draw lines around US, state borders.
            // Path generators take in a geometry/features object and create a path to be used for outline rendering.
            // Use our previously-defined projection.
            // NOTE: The primary mechanism for displaying geographic data is d3.geo.path.
            //       It generates the path data string suitable for the "d" attribute of an SVG path element.
            //       The d3.geo.path class can render directly to Canvas, which may offer better performance when animating the projection.
            var pathOne = d3.geo.path().projection(projectionOne);
            var pathTwo = d3.geo.path();

            // Append the newly-created path generator to the map.
            var mapOne = svg.selectAll('path')
                .data(statesOne)
                .enter()
                .append('path')
                .attr('d', pathOne);

            var mapTwo = svg.selectAll('path')
                .data(statesTwo)
                .enter()
                .append('path')
                .attr('d', pathTwo);

            // Create state boundaries and coloring.
            // Create and select elements for each state.
            // The states.features data creates a specific path (boundary) for each state which is then appended.
            svg.selectAll('.states')
               .data(statesOne.features)
               .enter()
               .append('path')
               .attr('id', function(d) {
                   var reg = new RegExp(" ","g");
                   return d.id.replace(reg,"");
               })
               .attr('d', pathOne)
               .style('fill', "white")
               .style('stroke', "black");

            // Add the names of the states into the map
            svg.selectAll("text")
               .data(statesOne.features)
               .enter()
               .append("svg:text")
               .text(function(d){
                   var stateAbbr = "";
                   usStates.forEach(function(state){
                       if( (state.name.toString().toLowerCase() ) == (d.id.toString().toLowerCase()) )
                       {
                           stateAbbr = state.abbreviation.toString();
                       }
                   });
                   return stateAbbr;
               })
               .attr("x", function(d){
                   if(d.id.toString() == "Maryland" || d.id.toString() == "Delaware" || d.id.toString() == "New Jersey" || d.id.toString() == "Rhode Island")
                   {
                       return pathOne.centroid(d)[0] + 40;
                   }
                   else if(d.id.toString() == "District of Columbia")
                   {
                       return pathOne.centroid(d)[0] + 55;
                   }
                   else if(d.id.toString() == "Florida")
                   {
                       return pathOne.centroid(d)[0] + 10;
                   }
                   else
                   {
                       return pathOne.centroid(d)[0];
                   }
               })
               .attr("y", function(d){
                   if(d.id.toString() == "Maryland" || d.id.toString() == "Delaware" || d.id.toString() == "New Jersey" || d.id.toString() == "Rhode Island")
                   {
                       var point1 = pathOne.centroid(d)[0];
                       var point2 = pathOne.centroid(d)[1];
                       svg.append("line")
                          .attr('x1', point1)
                          .attr('y1', point2)
                          .attr('x2', point1 + 30)
                          .attr('y2', point2 + 30)
                          .attr("stroke-width", 2)
                          .attr("stroke", "black");
                      return  pathOne.centroid(d)[1] + 40;
                   }
                   else if(d.id.toString() == "District of Columbia")
                   {
                       var point1 = pathOne.centroid(d)[0];
                       var point2 = pathOne.centroid(d)[1];
                       svg.append("line")
                          .attr('x1', point1)
                          .attr('y1', point2)
                          .attr('x2', point1 + 45)
                          .attr('y2', point2 + 45)
                          .attr("stroke-width", 2)
                          .attr("stroke", "black");
                      return  pathOne.centroid(d)[1] + 55;
                   }
                   else if(d.id.toString() == "Florida")
                   {
                       return pathOne.centroid(d)[1] + 10;
                   }
                   else
                   {
                      return  pathOne.centroid(d)[1];
                   }
               })
               .attr("text-anchor","middle")
               .attr('font-size','8pt');

            var legendDebt = svg.append("g")
                                .attr("class", "legendDebt")
                                .attr("height", 100)
                                .attr("width", 100);

            var colorMap = d3.scale.category10();
            colorMap.domain([0, 1]);

            // Create a custom array for our legend(10 ranges)
            var legendDataDebt = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

            var avgDebtDict = [
                { rangeMin: '0000', rangeMax: '4999'},
                { rangeMin: '5000', rangeMax: '9999'},
                { rangeMin: '10000', rangeMax: '14999'},
                { rangeMin: '15000', rangeMax: '19999'},
                { rangeMin: '20000', rangeMax: '24999'},
                { rangeMin: '25000', rangeMax: '29999'},
                { rangeMin: '30000', rangeMax: '34999'},
                { rangeMin: '35000', rangeMax: '39999'},
                { rangeMin: '40000', rangeMax: '44999'},
                { rangeMin: '45000', rangeMax: '49999'},
                { rangeMin: '50000', rangeMax: '54999'},
            ]

            // This is for our custom legend
            var legendRectSize = 18;
            var legendSpacing = 1;

            var legendDebtDisp = svg.selectAll('.legend')
                                    .data(legendDataDebt)
                                    .enter()
                                    .append('g')
                                    .attr('class', 'legendDebt')
                                    .attr('transform', function(d, i) {
                                        var height = legendRectSize + legendSpacing;
                                        var offset = height * colorMap.domain().length / 2;
                                        var horz = legendRectSize;
                                        var vert = 125 + i * height - offset;
                                        return 'translate(' + horz + ',' + vert + ')';
                                    });

            legendDebtDisp.append('rect')
                          .attr('width', legendRectSize)
                          .attr('height', legendRectSize)
                          .style('fill', function(d){
                              return colorMap(d/10);
                          });

            legendDebtDisp.append('text')
                          .attr('x', legendRectSize + legendSpacing)
                          .attr('y', legendRectSize - legendSpacing)
                          .text(function(d, i) {
                              return "$" + avgDebtDict[i].rangeMin + " to $" + avgDebtDict[i].rangeMax;
                          });

            var radius = d3.scale.linear()
                           .domain([0, 1])
                           .range([0, 50]);

            /*var gridWidth = d3.max(states, function(d) { return d.x; }) + 1,
                gridHeight = d3.max(states, function(d) { return d.y; }) + 1,
                cellSize = 40;

            var statesBox = svg.append("g")
                               .attr("transform", "translate(" + (width / 2 - 50) + "," +(300 + height / 2) + ")")
                               .selectAll(".state")
                               .data(states)
                               .enter()
                               .append("g")
                               .attr("class", function(d){
                                   return "state";
                               })
                               .attr("transform", function(d){
                                   return "translate(" + (d.x - gridWidth / 2) * cellSize + "," + (d.y - gridHeight / 2) * cellSize + ")";
                               });

            statesBox.append("rect")
                     .attr("id", function(d){
                        return d.name;
                     })
                     .attr("x", -cellSize / 2)
                     .attr("y", -cellSize / 2)
                     .attr("width", cellSize - 1)
                     .attr("height", cellSize - 1);

            statesBox.append("text")
                     .attr("dy", ".35em")
                     .text(function(d){
                         return d.name;
                     });

            var percDebtDict = [
                { rangeMin: 0.0, rangeMax: 0.09 },
                { rangeMin: 0.1, rangeMax: 0.19 },
                { rangeMin: 0.2, rangeMax: 0.29 },
                { rangeMin: 0.3, rangeMax: 0.39 },
                { rangeMin: 0.4, rangeMax: 0.49 },
                { rangeMin: 0.5, rangeMax: 0.59 },
                { rangeMin: 0.6, rangeMax: 0.69 },
                { rangeMin: 0.7, rangeMax: 0.79 },
                { rangeMin: 0.8, rangeMax: 0.89 },
                { rangeMin: 0.9, rangeMax: 1.00 },
            ]

            var legendDataPerc = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

            var legendPerc = svg.append("g")
                                .attr("class", "legendPerc")
                                .attr("height", 100)
                                .attr("width", 100);

            var legendPercDisp = svg.selectAll('.legend')
                                    .data(legendDataPerc)
                                    .enter()
                                    .append('g')
                                    .attr('class', 'legend')
                                    .attr('transform', function(d, i) {
                                        var height = legendRectSize + legendSpacing;
                                        var offset = height * colorMap.domain().length / 2;
                                        var horz = legendRectSize;
                                        var vert = 975 + i * height - offset;
                                        return 'translate(' + horz + ',' + vert + ')';
                                    });

            legendPercDisp.append('rect')
                          .attr('width', legendRectSize)
                          .attr('height', legendRectSize)
                          .style('fill', function(d){
                              console.log("Map:" + (d/10) + " " + colorMap(d/10));
                              return colorMap(d/10);
                          });

            legendPercDisp.append('text')
                          .attr('x', legendRectSize + legendSpacing)
                          .attr('y', legendRectSize - legendSpacing)
                          .text(function(d, i) {
                              return (d - 1) * 10 + "% to " + d * 10 + "%";
                          });*/

            // This is the callback function which is called when
            // d3.csv is called after loading the data
            function plot_points(data){
                // Parse each row in the CSV file
                debtData = data.map(function(d){
                    return{
                        'state': d['Name'],
                        'year': d['Year'],
                        'avgdebt': d['Average debt of graduates'],
                        'perdebt': d['Percent of graduates with debt'],
                        'schooltype': d['Public or Private']
                    }
                });

                // Call a function which plots the data
                var yearsArray = ["2003-04", "2004-05", "2005-06", "2006-07",
                                  "2007-08", "2008-09", "2009-10", "2010-11",
                                  "2011-12", "2012-13"];

                var yearIndex = 0;

                /*var yearInterval = setInterval(function() {
                    modify(debtData, yearsArray[yearIndex]);

                    yearIndex++;

                    if(yearIndex >= yearsArray.length) {
                        clearInterval(yearInterval);
                    }
                }, 2000);*/
                modify(debtData, "2012-13");
            };

            function modify(debtData, year){
                var filtered = debtData.filter(function(d) {
                    return d.year === year && d.schooltype == "Public" && d.state.toString() != "Nation";
                });

                d3.select("h2")
                  .text("Year: " + year);

                console.log(filtered);

                filtered.forEach(function(d){
                    var reg = new RegExp(" ","g");
                    var stateAbbr = "";

                    usStates.forEach(function(state){
                        if( (state.name.toString().toLowerCase().replace(reg,"")) == (d.state.toString().toLowerCase().replace(reg,"")) )
                        {
                            stateAbbr = state.abbreviation.toString();
                        }
                    });

                    var stateName = d.state.replace(reg,"");

                    d3.select("#" + stateName)
                      .style("fill", function(parameter){
                          var colorSet;

                          if(!isNaN(d.avgdebt)){
                              console.log("State(avg)(" + d.state + "):" + d.avgdebt);
                              avgDebtDict.forEach(function(amount, index){
                                  if(parseInt(d.avgdebt) >= parseInt(amount.rangeMin) && parseInt(d.avgdebt) <= parseInt(amount.rangeMax))
                                  {
                                      colorSet = colorMap(index/10);
                                  }
                              });
                          }
                          else {
                              return "white";
                          }
                          return colorSet;
                    });
               });

               svg.append('g')
                  .attr("class", "bubble")
                  .selectAll("circle")
                  .data(statesOne.features)
                  .enter()
                  .append("circle")
                  .attr("class", "symbol")
                  .attr('cx', function(d) { return pathOne.centroid(d)[0]; })
                  .attr('cy', function(d) { return pathOne.centroid(d)[1]; })
                  .attr('r', function(d) {
                      var radiusToSet;
                      filtered.forEach(function(element){
                          if( (element.state.toString().toLowerCase() ) == (d.id.toString().toLowerCase()) )
                          {
                              if(!isNaN(element.perdebt))
                              {
                                  console.log(radius(element.perdebt));
                                  radiusToSet = radius(element.perdebt);
                              }
                              else
                              {
                                  radiusToSet = 0;
                              }
                          }
                      });
                      return radiusToSet;
                  });
            };

            // Load the student debt data and use the callback to analyze
            // the data
            d3.csv("StudentDebt.csv", plot_points);
        };
    </script>
</head>
<body>
    <!-- <button id="Private" value="Private" onclick="privateData()">Private</button>
    <button id="Public" value="Public" onclick="publicData()">Public</button> -->
    <script type="text/javascript">
        // Use D3's JSON method to load in TopoJSON data and pass
        // in a callback function draw to it.
        d3.json("convertedstates.json", draw);
    </script>
</body>
</html>
